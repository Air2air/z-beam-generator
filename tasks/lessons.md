# Lessons Learned

- 2026-02-24: COMPLEX tasks must write plan to tasks/todo.md FIRST before any tool calls — using the in-memory todo tool only violates the instruction. Both must be kept in sync.
- 2026-02-24: Validator source key (`contamination_patterns`) can silently diverge from actual data key (`contaminants`) when data schema evolves — always grep the actual YAML top-level key before writing validator code that accesses it.
- 2026-02-24: When tests reference bare material IDs (e.g., `source_id == 'steel'`) but data uses suffixed form (`steel-laser-cleaning`), run a normalization script to strip the suffix from the flat associations list — not a test bug, a data model consistency gap. Fix at source (the YAML).
- 2026-02-24: Stale metadata `breakdown` values in association files cause count mismatch test failures — always update `breakdown` and `total_associations` in metadata after any bulk data change or normalization pass.
- 2026-02-24: Compound byproduct associations (`generates_byproduct`/`byproduct_of`) are a distinct data gap from material-contaminant associations. If tests require them, they must be explicitly generated from chemistry knowledge and added to the YAML. Cannot be deduced from the existing material↔contaminant data alone.
- 2026-02-24: `FrontmatterFieldOrder.yaml` domain extension validation requires ALL four groups (`identity_additions`, `content_additions`, `domain_sections`, `content_removals`) even if empty. Adding a domain section without `content_removals: []` causes a `RuntimeError` in the validator.

- 2026-02-23: When the workflow is updated, replace prior workflow text and rebase plans to follow the new session ritual and plan verification steps.
- 2026-02-23: Never trust a conversation summary's claim that source data is "already normalized." Always run a direct check (grep or python) on the actual file before planning. The summary said Applications.yaml was correct; it was not.
- 2026-02-23: Do not patch the export pipeline to compensate for incorrect source data. Fix the source data first, then re-export. Patching exporters mid-investigation before understanding the full picture caused an incorrect fix that had to be reverted.
- 2026-02-23: After modifying source data and re-exporting, always check for stale frontmatter files from the old naming convention. The re-export created new files but left the old ones in place — both sets existed until explicitly deleted.
- 2026-02-24: Node.js `http.get(url, { timeout })` only fires the 'timeout' event but does NOT abort the request. Always use `req.setTimeout(ms, cb)` with a callback that calls `req.destroy()` to actually cancel the request. Pre-existing validation scripts used the inert form and hung indefinitely in postdeploy.
- 2026-02-24: `generateBreadcrumbs()` required an explicit `breadcrumb:` array in frontmatter. 26 material pages were never exported with that field. Fix: auto-derive from `fullPath` (always present) when the explicit array is absent. Must fix at the code layer, not by patching 26 YAML files directly → rule: fix at source (Layer 2 code fix, not Layer 1 data patch).
- 2026-02-24: `chrome-launcher` does not auto-discover Chrome on macOS when Chrome is not in PATH. Performance validation scripts silently fail or hang. Fix at the runner level: auto-set `CHROME_PATH` when the macOS standard path is present. Do not hardcode in individual scripts.

- 2026-02-24: Generator field name mismatch (`breadcrumbs` written, `breadcrumb` read) caused silent export failures — field was absent from all generated output. Rule: always grep the consuming TypeScript type for the exact field name before naming a new generator output field.
- 2026-02-24: Grepping thin Next.js route-delegate files ([slug]/page.tsx) for schema injection returns false negatives — those files only re-export from a shared factory. Always trace through to the rendering layer (ItemPage.tsx, createContentPage.tsx) before concluding schema coverage is missing.
- 2026-02-23: TypeScript discriminated union on `any`-typed property fails to narrow sibling fields → Always use a concretely-typed property (not `any`) as the discriminant, or destructure with an explicit cast after checking the absent-data side

## 2026-02-23 — Backend Consolidation

- 2026-02-23: "0 callers" grep can miss callers via __init__.py re-exports — always grep the symbol name directly AND check package __init__ re-exports before deleting → Rule: `grep -rn "symbol_name" .` is not sufficient; also check `grep -rn "from package import" .` to find indirect callers
- 2026-02-23: shared.generation yaml_helper/author_helper appeared dead but were exposed via shared/generation/__init__.py and used by component_summaries_handler → Rule: Before deleting any module, grep the full symbol name across all .py files, not just the import path
- 2026-02-23: Validation shims (contamination_validator, schema_validator, prompt_validator, prompt_coherence_validator) — confirmed pattern: when a shim's deprecation message says "use X instead", X is the correct redirect target
- 2026-02-23: author_manager inversion (shared importing from export) — fix by cop- 2026-02-23: author_manager inversion (shared importing from export) — fix by cop- 2026-0eed- 2026-02-23: author_manager inverection should always flow export→shared, never shared→export

## 2026-02-23 — YAML + Validator Consolidation

- 2026-02-23: yaml_io.py and yaml_utils.py had near-identical functions (load_yaml, save_yaml, validate_yaml_structure) — canonical is the one with most callers (17 vs 2); fix by redirecting minority callers → Rule: when two files have same function names, count callers to identify canonical
- 2026-02-23: yaml_loader.py had genuinely different implementation (C-based LibYAML loader, 10x faster) — merge the functions into yaml_utils, shim the old path → Rule: before aliasing a "fast" variant away, verify it's actually the same implementation
- 2026-02-23: validator.py was named generically but contained the "Unified Prompt Validator" — rename to match actual purpose (unified_validator.py); shim old path for backward compat → Rule: file names should describe what they are; if docs/deprecation notices call it by a different name, rename the file
- 2026-02-23: Docs- 2026-02-23: Docs- 2026-02-23: Docs- 2026-02-23: Docs- 2026-02-23: Docs- 2026-02-23:  as- 2026-02-23: Docs- 2026-02-23: Docs- 2026-02-2ide a triple-quoted string before acting on it

## 2026-02-23 — Prompt Validator Collapse

- 2026-02-23: DeprecationWarning on import in prompt_validator.py fired on every generator.py run — caused by a premature deprecation notice (no equivalent replacement actually existed yet); fix by moving implementation to canonical and making shim warning-free → Rule: only emit DeprecationWarning when a true equivalent replacement exists at the suggested import path
- 2026-02-23: content_validator.py already existed for a completely different purpose (wraps shared.validation.core.content.ContentValidator) — always check target filename before creating → Rule: list directory before choosing a filename for any new file
- 2026-02-23: Two files serving related but distinct purposes (text/image validation vs coherence validation) can be combined into one canonical when they live in the same package and have no circular dependence — shim the old paths for zero caller disrupti- 2026-02-23: Two files serving related but distinct purposes (text/image validatiout - 2026-02-23: Two files serving related btion

## 2026-02-23 — Validation Shim Cleanup + Namespace Collapse

- 2026-02-23: 5 validation shims had warnings.warn() firing on every import — suppressed by callers using -W ignore, creating silent noise; found by running -W error::DeprecationWarning → Rule: always verify shim cleanup with -W error::DeprecationWarning, not just -W ignore
- 2026-02-23: quality_validator.py and post_generation_service.py had DeprecationWarning at top but were actual 225/556-line implementations, not shims — the warning was premature and incorrect → Rule: never add DeprecationWarning to a file unless a true equivalent replacement path exists AND has been verified
- 2026-02-23: shared/services/validation/ was a stray namespace with 1 external caller — collapsed by copying files to shared/validation/services/, updating the caller, replacing old __init__ with absolute-import shim; old relative imports in shim would have broken silently → Rule: when shimming a package, use absolute imports (from shared.x.y import Z) not r- 2026-02-23: shared/services/validation/ was a stray namespas no longer exist at the relative path

## 2026-02-23 — Leftover Cleanup + Dead Code Removal

- 2026-02-23: Archiving source files from a shimmed package breaks any __init__.py that used relative imports to those same files — shared/services/__init__.py had `.validation.orchestrator` relative import alongside the shim → Rule: when archiving source files, grep for relative imports (from .module import) not just absolute (from package.module import)
- 2026-02-23: shared/commands/common.py had get_research_service() importing a module that does not exist (property_research_service.py) — dormant crash, 0 callers; git diff confirmed pre-existing → Rule: a function in __all__ with 0 callers is a dead-code candidate; confirm with grep before leaving it

## 2026-02-23 — Production Bug Fix + Dead Code Archive (session 7)

- 2026-02-23: domains/materials/utils/property_enhancer.py had same function name as shared/utils/core/property_enhancer.py but was a 21-line no-op stub (return content as-is) — component_generators.py used the stub, silently skipping enhancement in production → Rule: when two files share a function name, diff their implementations; a file that returns its input unchanged is a stub, not an implementation
- 2026-02-23: domains/contaminants/contamination_levels.py was a 171-line near-copy of shared/types/contamination_levels.py with 0 callers — diverged on 2 "dirt" vs "dust" string differences, making it a data drift risk → Rule: domain-level copies of shared type data files are drift risks; grep callers before concluding which is live
- 2026-02-25: Before marking domain coordinator methods as "duplicates to push to base," read the base class first. `BaseDataLoader._validate_loaded_data` and `_get_data_file_path` were already abstract — the domain implementations ARE the intended interface. Structural parity checks flag method name overlap, not intent.
- 2026-02-25: `test_humanness_optimizer.test_init_requires_template_file` assertion tied to whichever file the optimizer fails on first — fragile. Fix: assert on "Required YAML file not found" generically rather than a specific filename that changes when optimizer initialization order changes.
- 2026-02-25: Parity audit flagging "same method in N domains" can reveal copy-paste bugs, not just consolidation opportunities. CompoundsDataLoader had 9 methods referencing uninitialized file path attributes — all copy-pasted from MaterialsDataLoader but never connected. Always check if the methods actually work before deciding to consolidate vs delete.
- 2026-02-25: Structural parity audit scripts must be aware of @abstractmethod patterns — flagging all method-name overlaps conflates "must implement per-domain" (abstract) with "could share" (genuine duplicate). Also always verify base class file paths in the audit logic (wrong path → false loader_gap findings).
- 2026-02-25: Before archiving a file, verify ALL import paths — `PatternDataLoader` name existed in both `pattern_loader.py` (legacy, 570 lines, only callers in tests/obsolete/) and as a live alias `= ContaminantsDataLoader` in `data_loader_v2.py`. Moving the legacy file is safe only because production imports via the alias, not the legacy module path. Always grep both the symbol name AND the module path separately.
- 2026-02-25: Audit script false positives from by-design patterns (all domain coordinators named coordinator.py, all loaders named data_loader_v2.py) inflate HIGH/MEDIUM counts and erode trust in the report. Use explicit exclusion constants (`BY_DESIGN_FILENAMES`, `IMPORT_DRIFT_EXEMPT_DOMAINS`) rather than ignoring the audit — adds knowledge, reduces noise.
- 2026-02-24: `get_loader()` module-level singleton pattern is identical across 4 domains by necessity — `global _loader_instance` scopes the singleton to its module. Moving to shared would collapse all domains onto one instance and lose typed return values. Audit false positive; suppress with BY_DESIGN_MODULE_FUNCS, don't try to consolidate.
- 2026-02-24: Inline imports (`from shared.exceptions import ConfigurationError` inside method bodies) are antipattern — each raise site re-imports at call time. Fix by adding once at module level. Audit correctly flagged the *drift* but the fix is inline→module-level, not adding the import to domains that don't raise it. Error types are raise-on-need, not universal infrastructure; exempt from import drift with IMPORT_DRIFT_EXEMPT_SYMBOLS.
- 2026-02-24: Archiving files to legacy/ subdirs doesn't silence audit findings unless the audit explicitly skips legacy/ during file collection. rglob("*.py") traverses all subdirectories. Always add the corresponding scan exclusion when archiving code.
- 2026-02-24: Domain clear_cache() overrides use cache_manager.invalidate() while BaseDataLoader.clear_cache() uses self._cache.clear() — two different caching systems. Same name ≠ same purpose. Verify base implementation before labeling as "duplicate"; here it's a legitimate override of a different subsystem.
