"""
Relationship URL Enricher - Dynamically generates URL fields in relationships.

This enricher:
1. Builds an index of all frontmatter files (id ‚Üí full_path mapping)
2. For each relationship field (produces_compounds, related_materials, etc.)
3. For each relationship item with an 'id' field
4. Looks up the target in the index
5. Sets item['url'] = target's full_path

This ensures relationship URLs always match the target's actual full_path,
even after structural changes or category hierarchy updates.

Example:
    Before:
        produces_compounds:
          - id: pahs-compound
            url: /compounds/general/misc/pahs-compound  # Stale
    
    After:
        produces_compounds:
          - id: pahs-compound
            url: /compounds/carcinogen/aromatic-hydrocarbon/pahs-compound  # Current
"""

import os
import yaml
from typing import Dict, Any, List, Optional
from pathlib import Path
import logging

from export.enrichers.base import BaseEnricher

logger = logging.getLogger(__name__)


class RelationshipURLEnricher(BaseEnricher):
    """
    Enricher that dynamically generates URL fields in relationship arrays.
    
    This enricher must run AFTER linkage enrichment (so relationships exist)
    but BEFORE cleanup (so we can update the fields).
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize enricher.
        
        Args:
            config: Enricher config dict
        """
        super().__init__(config)
        self.frontmatter_root = "../z-beam/frontmatter"
        self.index: Dict[str, str] = {}  # id ‚Üí full_path mapping
        self.index_built = False
        logger.info("Initialized RelationshipURLEnricher")
    
    def _build_index(self):
        """
        Build index of all frontmatter files.
        
        Creates mapping: item_id ‚Üí full_path
        
        This is called lazily on first enrich() call, after frontmatter
        files have been generated by earlier enrichers.
        """
        print(f"üîó Building relationship URL index from disk...")
        frontmatter_path = Path(self.frontmatter_root)
        if not frontmatter_path.exists():
            logger.warning(f"Frontmatter directory not found: {self.frontmatter_root}")
            self.index_built = True
            return
        
        # Scan all domains
        for domain_dir in frontmatter_path.iterdir():
            if not domain_dir.is_dir():
                continue
            
            # Recursively find all .yaml files
            yaml_files = list(domain_dir.rglob("*.yaml"))
            
            for yaml_file in yaml_files:
                try:
                    with open(yaml_file, 'r', encoding='utf-8') as f:
                        data = yaml.safe_load(f)
                    
                    if data and 'id' in data and 'full_path' in data:
                        self.index[data['id']] = data['full_path']
                
                except Exception as e:
                    logger.warning(f"Error reading {yaml_file}: {e}")
        
        self.index_built = True
        logger.info(f"Built relationship URL index: {len(self.index)} items")
    
    def enrich(self, frontmatter: Dict[str, Any]) -> Dict[str, Any]:
        """
        Enrich relationship fields with correct URLs.
        
        Args:
            frontmatter: Frontmatter dictionary
        
        Returns:
            Updated frontmatter with correct relationship URLs
        """
        item_id = frontmatter.get('id', 'unknown')
        print(f"üîó RelationshipURLEnricher.enrich() called for {item_id}")
        
        try:
            # Build index on first call (after frontmatter files exist)
            if not self.index_built:
                print(f"üîó Building relationship URL index...")
                self._build_index()
                print(f"üìä Index built: {len(self.index)} items")
                # Debug: Show sample entries
                if 'pahs-compound' in self.index:
                    print(f"  ‚úÖ pahs-compound ‚Üí {self.index['pahs-compound']}")
                if 'fire-damage-contamination' in self.index:
                    print(f"  ‚úÖ fire-damage-contamination ‚Üí {self.index['fire-damage-contamination']}")
            
            print(f"  Step 1: index_built={self.index_built}, index size={len(self.index)}")
            
            # Debug: show what's in index for pahs-compound
            if 'pahs-compound' in self.index:
                print(f"  Index has pahs-compound ‚Üí {self.index['pahs-compound']}")
            else:
                print(f"  ‚ö†Ô∏è  pahs-compound NOT in index!")
            
            print(f"  Step 2: Checking relationships...")
            
            # Update index with current item's full_path (for items in same export run)
            if 'id' in frontmatter and 'full_path' in frontmatter:
                current_id = frontmatter['id']
                current_path = frontmatter['full_path']
                if current_id not in self.index or self.index[current_id] != current_path:
                    self.index[current_id] = current_path
                    print(f"  üìù Updated index: {current_id} ‚Üí {current_path}")
            
            print(f"  Step 3: Has relationships: {'relationships' in frontmatter}")
            
            if 'relationships' not in frontmatter:
                return frontmatter
            
            relationships = frontmatter['relationships']
            print(f"  Step 4: relationships is dict: {isinstance(relationships, dict)}")
            
            if not isinstance(relationships, dict):
                return frontmatter
            
            updated_count = 0
            
            # Debug for fire-damage
            item_id = frontmatter.get('id', 'unknown')
            if item_id == 'fire-damage-contamination' and 'produces_compounds' in relationships:
                print(f"\nüîç DEBUG fire-damage-contamination:")
                for item in relationships['produces_compounds']:
                    print(f"  Item: {item.get('id')} ‚Üí {item.get('url', 'NO_URL')}")
            
            # Process each relationship type
            for rel_type, rel_items in relationships.items():
                if not isinstance(rel_items, list):
                    continue
                
                # Process each item in the relationship array
                for item in rel_items:
                    if not isinstance(item, dict):
                        continue
                    
                    if 'id' not in item:
                        continue
                    
                    target_id = item['id']
                    
                    # Debug all pahs-compound updates
                    if target_id == 'pahs-compound':
                        current_url = item.get('url', 'NO_URL')
                        if target_id in self.index:
                            correct_url = self.index[target_id]
                            print(f"  üîç {frontmatter.get('id')}: pahs-compound current={current_url}, correct={correct_url}, match={current_url == correct_url}")
                        else:
                            print(f"  ‚ö†Ô∏è  {frontmatter.get('id')}: pahs-compound not in index!")
                    
                    # Look up target's full_path in index
                    if target_id in self.index:
                        correct_url = self.index[target_id]
                        old_url = item.get('url', 'NO_URL')
                        
                        # Update URL if different or missing
                        if 'url' not in item or item['url'] != correct_url:
                            print(f"  üîß Updating {target_id}: {old_url} ‚Üí {correct_url}")
                            item['url'] = correct_url
                            updated_count += 1
                    else:
                        # Target not found (might be library item)
                        if 'url' not in item:
                            # No URL and not in index - log warning
                            logger.debug(f"Relationship target not found: {target_id} (from {frontmatter.get('id', 'unknown')})")
            
            if updated_count > 0:
                logger.info(f"Updated {updated_count} relationship URLs for {frontmatter.get('id', 'unknown')}")
            
            return frontmatter
        except Exception as e:
            print(f"‚ùå ERROR in enrich: {e}")
            import traceback
            traceback.print_exc()
            raise
