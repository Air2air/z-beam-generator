"""
Materials Restructure Enricher - Remove duplicates and legacy fields

Cleans up materials frontmatter:
- regulatory_standards (root) → REMOVED (duplicate of relationships.regulatory)
- metadata, eeat, voice_enhanced → REMOVED (legacy fields)
- KEEPS domain-specific data at root: characteristics, properties, components, applications, contamination

Created: December 19, 2025
Purpose: Cleanup of materials domain - remove duplicates and legacy fields only
Pattern: Following CompoundRestructureEnricher architecture
"""

import logging
from typing import Dict, Any

from export.enrichers.base import BaseEnricher

logger = logging.getLogger(__name__)


class MaterialsRestructureEnricher(BaseEnricher):
    """
    Restructure materials frontmatter by removing duplicates and legacy fields.
    
    BEFORE:
    ```yaml
    id: Aluminum
    regulatory_standards: [...]  # DUPLICATE of relationships.regulatory
    characteristics: {...}       # KEEP - domain data
    properties: {...}            # KEEP - domain data
    metadata: {...}              # REMOVE - legacy
    eeat: {...}                  # REMOVE - legacy
    voice_enhanced: true         # REMOVE - legacy
    relationships:
      regulatory: [...]
    ```
    
    AFTER:
    ```yaml
    id: Aluminum
    characteristics: {...}       # KEPT - domain data
    properties: {...}            # KEPT - domain data
    relationships:
      regulatory: [...]         # regulatory_standards removed (duplicate)
    ```
    """
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize materials restructure enricher."""
        super().__init__(config)
        logger.info("Initialized MaterialsRestructureEnricher")
    
    def enrich(self, frontmatter: Dict[str, Any]) -> Dict[str, Any]:
        """
        Remove duplicate and legacy fields.
        
        Args:
            frontmatter: Input frontmatter dict
        
        Returns:
            Cleaned frontmatter
        """
        # Initialize relationships if missing
        if 'relationships' not in frontmatter:
            frontmatter['relationships'] = {}
        
        # 1. Remove OLD relationship keys that will be regenerated by DomainLinkagesService
        #    These have WRONG URLs (nested category paths) - service generates CORRECT URLs
        old_relationship_keys = ['related_contaminants', 'related_materials', 'related_compounds']
        for key in old_relationship_keys:
            # Check both root and relationships.key
            if key in frontmatter:
                frontmatter.pop(key)
                logger.debug(f"Removed old relationship key '{key}' from root (will be regenerated)")
            if key in frontmatter.get('relationships', {}):
                frontmatter['relationships'].pop(key)
                logger.debug(f"Removed old relationship key '{key}' from relationships (will be regenerated)")
        
        # 2. Remove duplicate regulatory_standards (keep relationships.regulatory)
        if 'regulatory_standards' in frontmatter:
            # If relationships.regulatory doesn't exist, migrate it
            if 'regulatory' not in frontmatter['relationships'] and frontmatter['regulatory_standards']:
                frontmatter['relationships']['regulatory_standards'] = frontmatter['regulatory_standards']
                logger.debug(f"Migrated regulatory_standards to relationships.regulatory_standards")
            # Remove root duplicate
            frontmatter.pop('regulatory_standards')
            logger.debug(f"Removed duplicate regulatory_standards from root")
        
        # 3. Remove legacy fields
        legacy_fields = ['metadata', 'eeat', 'voice_enhanced']
        removed_count = 0
        for field in legacy_fields:
            if field in frontmatter:
                frontmatter.pop(field)
                removed_count += 1
        
        if removed_count > 0:
            logger.debug(f"Removed {removed_count} legacy fields: {', '.join([f for f in legacy_fields if f not in frontmatter])}")
        
        return frontmatter
