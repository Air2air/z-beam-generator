"""
Universal Restructure Enricher - Consolidates domain-specific restructure logic

Replaces 4 domain-specific restructure enrichers (621 lines → ~150 lines, 75% reduction):
- materials_restructure_enricher.py (101 lines)
- compound_restructure_enricher.py (303 lines)
- contaminant_restructure_enricher.py (137 lines)
- settings_restructure_enricher.py (80 lines)

Key Features:
- Domain-agnostic: Handles all domains via configuration
- Configurable cleanup rules per domain
- Removes duplicates and legacy fields
- Migrates top-level technical data to relationships.*

Usage in export/config/{domain}.yaml:
    enrichers:
      - type: universal_restructure
        domain: materials  # materials, contaminants, compounds, settings
        cleanup_rules:
          old_relationship_keys: [related_contaminants, related_materials]
          legacy_fields: [metadata, eeat, voice_enhanced]
          duplicate_fields:
            regulatory_standards: regulatory  # root field → relationships.field
          move_to_relationships:
            - visual_characteristics
            - laser_properties
            - eeat

Created: December 19, 2025
Purpose: Code consolidation and maintainability
"""

import logging
from typing import Any, Dict, List

from export.enrichers.base import BaseEnricher

logger = logging.getLogger(__name__)


class UniversalRestructureEnricher(BaseEnricher):
    """
    Universal restructure enricher for all domains.
    
    Supports configurable cleanup operations:
    1. Remove old relationship keys (will be regenerated by DomainLinkagesService)
    2. Remove legacy fields (obsolete metadata)
    3. Remove duplicate fields (exist in both root and relationships)
    4. Move technical data from root to relationships (contaminants/compounds)
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize universal restructure enricher.
        
        Args:
            config: Enricher configuration with cleanup_rules
        """
        super().__init__(config)
        
        self.domain = config.get('domain', 'unknown')
        self.cleanup_rules = config.get('cleanup_rules', {})
        
        # Extract cleanup rules
        self.old_relationship_keys = self.cleanup_rules.get('old_relationship_keys', [])
        self.legacy_fields = self.cleanup_rules.get('legacy_fields', [])
        self.duplicate_fields = self.cleanup_rules.get('duplicate_fields', {})
        self.move_to_relationships = self.cleanup_rules.get('move_to_relationships', [])
        
        logger.info(
            f"Initialized UniversalRestructureEnricher for domain: {self.domain} "
            f"(old_keys={len(self.old_relationship_keys)}, "
            f"legacy={len(self.legacy_fields)}, "
            f"duplicates={len(self.duplicate_fields)}, "
            f"moves={len(self.move_to_relationships)})"
        )
    
    def enrich(self, frontmatter: Dict[str, Any]) -> Dict[str, Any]:
        """
        Restructure frontmatter based on domain-specific cleanup rules.
        
        Args:
            frontmatter: Input frontmatter dict
        
        Returns:
            Cleaned frontmatter
        """
        # Initialize relationships if missing
        if 'relationships' not in frontmatter:
            frontmatter['relationships'] = {}
        
        # Apply cleanup operations in order
        self._remove_old_relationship_keys(frontmatter)
        self._remove_duplicate_fields(frontmatter)
        self._remove_legacy_fields(frontmatter)
        self._move_fields_to_relationships(frontmatter)
        
        return frontmatter
    
    def _remove_old_relationship_keys(self, frontmatter: Dict[str, Any]) -> None:
        """
        Remove old relationship keys that will be regenerated.
        
        These keys have WRONG URLs (from old system) and will be regenerated
        by DomainLinkagesService with correct full hierarchical URLs.
        
        Args:
            frontmatter: Frontmatter dict to clean
        """
        if not self.old_relationship_keys:
            return
        
        removed_count = 0
        for key in self.old_relationship_keys:
            # Check both root and relationships.key
            if key in frontmatter:
                frontmatter.pop(key)
                removed_count += 1
                logger.debug(f"Removed old relationship key '{key}' from root")
            
            if key in frontmatter.get('relationships', {}):
                frontmatter['relationships'].pop(key)
                removed_count += 1
                logger.debug(f"Removed old relationship key '{key}' from relationships")
        
        if removed_count > 0:
            logger.debug(
                f"[{self.domain}] Removed {removed_count} old relationship keys "
                f"(will be regenerated)"
            )
    
    def _remove_duplicate_fields(self, frontmatter: Dict[str, Any]) -> None:
        """
        Remove duplicate fields that exist in both root and relationships.
        
        Example: regulatory_standards (root) duplicates relationships.regulatory
        
        Args:
            frontmatter: Frontmatter dict to clean
        """
        if not self.duplicate_fields:
            return
        
        removed_count = 0
        relationships = frontmatter.get('relationships', {})
        
        for root_field, rel_field in self.duplicate_fields.items():
            if root_field in frontmatter:
                # If relationships field doesn't exist, migrate data first
                if rel_field not in relationships and frontmatter[root_field]:
                    relationships[rel_field] = frontmatter[root_field]
                    logger.debug(f"Migrated {root_field} → relationships.{rel_field}")
                
                # Remove root duplicate
                frontmatter.pop(root_field)
                removed_count += 1
                logger.debug(f"Removed duplicate {root_field} from root")
        
        if removed_count > 0:
            logger.debug(
                f"[{self.domain}] Removed {removed_count} duplicate fields"
            )
    
    def _remove_legacy_fields(self, frontmatter: Dict[str, Any]) -> None:
        """
        Remove legacy fields that are no longer used.
        
        Example: metadata, eeat (old version), voice_enhanced
        
        Args:
            frontmatter: Frontmatter dict to clean
        """
        if not self.legacy_fields:
            return
        
        removed_count = 0
        for field in self.legacy_fields:
            if field in frontmatter:
                frontmatter.pop(field)
                removed_count += 1
        
        if removed_count > 0:
            removed_names = ', '.join([f for f in self.legacy_fields if f not in frontmatter])
            logger.debug(
                f"[{self.domain}] Removed {removed_count} legacy fields: {removed_names}"
            )
    
    def _move_fields_to_relationships(self, frontmatter: Dict[str, Any]) -> None:
        """
        Move technical data fields from root to relationships.*.
        
        Used by contaminants and compounds to group technical data.
        
        Args:
            frontmatter: Frontmatter dict to restructure
        """
        if not self.move_to_relationships:
            return
        
        moved_count = 0
        relationships = frontmatter['relationships']
        
        for field in self.move_to_relationships:
            if field in frontmatter:
                # Move field to relationships
                relationships[field] = frontmatter.pop(field)
                moved_count += 1
                logger.debug(f"Moved {field} → relationships.{field}")
        
        if moved_count > 0:
            logger.debug(
                f"[{self.domain}] Moved {moved_count} fields to relationships"
            )
