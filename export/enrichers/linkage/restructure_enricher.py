"""
Universal Restructure Enricher - Consolidates domain-specific restructure logic

Replaces 4 domain-specific restructure enrichers (621 lines → ~150 lines, 75% reduction):
- materials_restructure_enricher.py (101 lines)
- compound_restructure_enricher.py (303 lines)
- contaminant_restructure_enricher.py (137 lines)
- settings_restructure_enricher.py (80 lines)

Key Features:
- Domain-agnostic: Handles all domains via configuration
- Configurable cleanup rules per domain
- Removes duplicates and legacy fields
- Migrates top-level technical data to relationships.*

Usage in export/config/{domain}.yaml:
    enrichers:
      - type: universal_restructure
        domain: materials  # materials, contaminants, compounds, settings
        cleanup_rules:
          old_relationship_keys: [related_contaminants, related_materials]
          legacy_fields: [metadata, eeat, voice_enhanced]
          duplicate_fields:
            regulatory_standards: regulatory  # root field → relationships.field
          move_to_relationships:
            - visual_characteristics
            - laser_properties
            - eeat

Created: December 19, 2025
Purpose: Code consolidation and maintainability
"""

import logging
from typing import Any, Dict, List

from export.enrichers.base import BaseEnricher

logger = logging.getLogger(__name__)


class UniversalRestructureEnricher(BaseEnricher):
    """
    Universal restructure enricher for all domains.
    
    Supports configurable cleanup operations:
    1. Remove old relationship keys (will be regenerated by DomainLinkagesService)
    2. Remove legacy fields (obsolete metadata)
    3. Remove duplicate fields (exist in both root and relationships)
    4. Move technical data from root to relationships (contaminants/compounds)
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize universal restructure enricher.
        
        Args:
            config: Enricher configuration with cleanup_rules
        """
        super().__init__(config)
        
        self.domain = config.get('domain', 'unknown')
        self.cleanup_rules = config.get('cleanup_rules', {})
        
        # Extract cleanup rules
        self.old_relationship_keys = self.cleanup_rules.get('old_relationship_keys', [])
        self.legacy_fields = self.cleanup_rules.get('legacy_fields', [])
        self.duplicate_fields = self.cleanup_rules.get('duplicate_fields', {})
        self.move_to_relationships = self.cleanup_rules.get('move_to_relationships', [])
        self.extract_from_nested = self.cleanup_rules.get('extract_from_nested', {})
        self.keep_at_top_level = self.cleanup_rules.get('keep_at_top_level', [])
        
        logger.info(
            f"Initialized UniversalRestructureEnricher for domain: {self.domain} "
            f"(old_keys={len(self.old_relationship_keys)}, "
            f"legacy={len(self.legacy_fields)}, "
            f"duplicates={len(self.duplicate_fields)}, "
            f"moves={len(self.move_to_relationships)}, "
            f"extract_nested={len(self.extract_from_nested)}, "
            f"keep_top={len(self.keep_at_top_level)})"
        )
    
    def enrich(self, frontmatter: Dict[str, Any]) -> Dict[str, Any]:
        """
        Restructure frontmatter based on domain-specific cleanup rules.
        
        Args:
            frontmatter: Input frontmatter dict
        
        Returns:
            Cleaned frontmatter
        """
        # Initialize relationships if missing
        if 'relationships' not in frontmatter:
            frontmatter['relationships'] = {}
        
        # Apply cleanup operations in order
        self._extract_from_nested_fields(frontmatter)
        self._remove_old_relationship_keys(frontmatter)
        self._remove_duplicate_fields(frontmatter)
        self._remove_legacy_fields(frontmatter)
        self._move_fields_to_relationships(frontmatter)
        self._keep_fields_at_top_level(frontmatter)
        
        return frontmatter
    
    def _remove_old_relationship_keys(self, frontmatter: Dict[str, Any]) -> None:
        """
        Remove old relationship keys that will be regenerated.
        
        These keys have WRONG URLs (from old system) and will be regenerated
        by DomainLinkagesService with correct full hierarchical URLs.
        
        Args:
            frontmatter: Frontmatter dict to clean
        """
        if not self.old_relationship_keys:
            return
        
        removed_count = 0
        for key in self.old_relationship_keys:
            # Check both root and relationships.key
            if key in frontmatter:
                frontmatter.pop(key)
                removed_count += 1
                logger.debug(f"Removed old relationship key '{key}' from root")
            
            if key in frontmatter.get('relationships', {}):
                frontmatter['relationships'].pop(key)
                removed_count += 1
                logger.debug(f"Removed old relationship key '{key}' from relationships")
        
        if removed_count > 0:
            logger.debug(
                f"[{self.domain}] Removed {removed_count} old relationship keys "
                f"(will be regenerated)"
            )
    
    def _remove_duplicate_fields(self, frontmatter: Dict[str, Any]) -> None:
        """
        Remove duplicate fields that exist in both root and relationships.
        
        Example: regulatory_standards (root) duplicates relationships.regulatory
        
        When migrating to relationships, wraps data in presentation structure:
        {presentation: 'card', items: [...]}
        
        Args:
            frontmatter: Frontmatter dict to clean
        """
        if not self.duplicate_fields:
            return
        
        removed_count = 0
        relationships = frontmatter.get('relationships', {})
        
        for root_field, rel_field in self.duplicate_fields.items():
            if root_field in frontmatter:
                root_data = frontmatter[root_field]
                
                # If relationships field doesn't exist, migrate data first
                if rel_field not in relationships and root_data:
                    # Wrap in presentation structure (card restructure format)
                    if isinstance(root_data, list):
                        relationships[rel_field] = {
                            'presentation': 'card',
                            'items': root_data
                        }
                        logger.debug(f"Migrated {root_field} → relationships.{rel_field} (wrapped with presentation='card')")
                    elif isinstance(root_data, dict):
                        # Wrap single dict as single-item array
                        relationships[rel_field] = {
                            'presentation': 'card',
                            'items': [root_data]
                        }
                        logger.debug(f"Migrated {root_field} → relationships.{rel_field} (wrapped dict with presentation='card')")
                    else:
                        # Handle other types (shouldn't happen but be defensive)
                        relationships[rel_field] = root_data
                        logger.debug(f"Migrated {root_field} → relationships.{rel_field} (non-list/dict)")
                
                # Remove root duplicate
                frontmatter.pop(root_field)
                removed_count += 1
                logger.debug(f"Removed duplicate {root_field} from root")
        
        if removed_count > 0:
            logger.debug(
                f"[{self.domain}] Removed {removed_count} duplicate fields"
            )
    
    def _remove_legacy_fields(self, frontmatter: Dict[str, Any]) -> None:
        """
        Remove legacy fields that are no longer used.
        
        Example: metadata, eeat (old version), voice_enhanced
        
        Args:
            frontmatter: Frontmatter dict to clean
        """
        if not self.legacy_fields:
            return
        
        removed_count = 0
        for field in self.legacy_fields:
            if field in frontmatter:
                frontmatter.pop(field)
                removed_count += 1
        
        if removed_count > 0:
            removed_names = ', '.join([f for f in self.legacy_fields if f not in frontmatter])
            logger.debug(
                f"[{self.domain}] Removed {removed_count} legacy fields: {removed_names}"
            )
    
    def _move_fields_to_relationships(self, frontmatter: Dict[str, Any]) -> None:
        """
        Move technical data fields from root to relationships.*.
        
        Used by contaminants and compounds to group technical data.
        
        Args:
            frontmatter: Frontmatter dict to restructure
        """
        if not self.move_to_relationships:
            return
        
        moved_count = 0
        relationships = frontmatter['relationships']
        
        for field in self.move_to_relationships:
            if field in frontmatter:
                # Move field to relationships
                relationships[field] = frontmatter.pop(field)
                moved_count += 1
                logger.debug(f"Moved {field} → relationships.{field}")
        
        if moved_count > 0:
            logger.debug(
                f"[{self.domain}] Moved {moved_count} fields to relationships"
            )
    
    def _extract_from_nested_fields(self, frontmatter: Dict[str, Any]) -> None:
        """
        Extract specific fields from nested structures before processing.
        
        Example: Extract safety_data from laser_properties.safety_data
        
        Args:
            frontmatter: Frontmatter dict to restructure
        """
        if not self.extract_from_nested:
            return
        
        extracted_count = 0
        for parent_field, fields_to_extract in self.extract_from_nested.items():
            if parent_field in frontmatter and isinstance(frontmatter[parent_field], dict):
                parent_data = frontmatter[parent_field]
                
                for field in fields_to_extract:
                    if field in parent_data:
                        # Extract to root level temporarily
                        frontmatter[field] = parent_data.pop(field)
                        extracted_count += 1
                        logger.debug(f"Extracted {parent_field}.{field} → root.{field}")
        
        if extracted_count > 0:
            logger.debug(
                f"[{self.domain}] Extracted {extracted_count} fields from nested structures"
            )
    
    def _keep_fields_at_top_level(self, frontmatter: Dict[str, Any]) -> None:
        """
        Keep specified fields at both top level and in relationships.
        
        These fields will exist in both locations:
        - Top-level for easy access
        - In relationships for semantic grouping
        
        Args:
            frontmatter: Frontmatter dict to process
        """
        if not self.keep_at_top_level:
            return
        
        kept_count = 0
        relationships = frontmatter.get('relationships', {})
        
        for field in self.keep_at_top_level:
            # If field exists in relationships, copy to top level
            if field in relationships:
                frontmatter[field] = relationships[field]
                kept_count += 1
                logger.debug(f"Kept {field} at top level (also in relationships)")
            # If field exists at top level, copy to relationships
            elif field in frontmatter:
                relationships[field] = frontmatter[field]
                kept_count += 1
                logger.debug(f"Copied {field} to relationships (also at top level)")
        
        if kept_count > 0:
            logger.debug(
                f"[{self.domain}] Kept {kept_count} fields at both top level and relationships"
            )

