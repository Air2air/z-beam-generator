#!/usr/bin/env python3
"""
Winston.ai AI Detection Provider
"""

import os
import time
import logging
import requests
from typing import Dict, Optional
from pathlib import Path

from ..service import AIDetectionResult, AIDetectionConfig, AIDetectionError

logger = logging.getLogger(__name__)

class WinstonProvider:
    """Winston.ai AI detection provider"""

    def __init__(self, config: AIDetectionConfig):
        self.config = config
        self.api_key = self._get_api_key()
        self.base_url = "https://api.gowinston.ai"
        self.session = requests.Session()

        if self.api_key:
            self.session.headers.update({
                'Authorization': f'Bearer {self.api_key}',
                'Content-Type': 'application/json',
                'User-Agent': 'Z-Beam-Generator/1.0'
            })

    def analyze_text(self, text: str, options: Optional[Dict] = None) -> AIDetectionResult:
        """Analyze text for AI detection score"""
        if not self.api_key:
            raise AIDetectionError("Winston.ai API key not configured")

        start_time = time.time()

        payload = {
            "text": text,
            "sentences": True  # Get sentence-level scores
        }

        # Add optional parameters
        if options:
            if 'version' in options:
                payload['version'] = options['version']
            if 'language' in options:
                payload['language'] = options['language']

        try:
            response = self.session.post(
                f"{self.base_url}/v2/ai-content-detection",
                json=payload,
                timeout=self.config.timeout
            )

            if response.status_code == 200:
                data = response.json()

                # Winston.ai returns score as 0-100 (higher = more AI-like)
                ai_score = data.get('score', 0.0)

                # Determine classification based on score
                if ai_score > 70:
                    classification = "ai"
                elif ai_score < 30:
                    classification = "human"
                else:
                    classification = "unclear"

                # Calculate confidence based on the score spread from 50
                confidence = min(abs(ai_score - 50) / 50, 1.0)

                # Extract sentence-level details if available
                details = {
                    "input": data.get("input", text),
                    "readability_score": data.get("readability_score"),
                    "credits_used": data.get("credits_used", 0),
                    "credits_remaining": data.get("credits_remaining"),
                    "version": data.get("version"),
                    "language": data.get("language"),
                    "attack_detected": data.get("attack_detected", {})
                }

                # Add sentence-level analysis if available
                if "sentences" in data and data["sentences"]:
                    details["sentences"] = data["sentences"]

                return AIDetectionResult(
                    score=ai_score,
                    confidence=confidence,
                    classification=classification,
                    details=details,
                    processing_time=time.time() - start_time,
                    provider="winston"
                )
            else:
                logger.error(f"Winston.ai API error: {response.status_code} - {response.text}")
                raise AIDetectionError(f"API error {response.status_code}")

        except requests.exceptions.Timeout:
            raise AIDetectionError("Winston.ai API request timeout")
        except requests.exceptions.RequestException as e:
            raise AIDetectionError(f"Winston.ai API request failed: {e}")
        except Exception as e:
            logger.error(f"Winston.ai analysis failed: {e}")
            raise AIDetectionError(f"Analysis failed: {e}")

    def is_available(self) -> bool:
        """Check if Winston.ai service is available"""
        if not self.api_key:
            return False

        try:
            # Simple health check - use the same text that worked in curl
            test_text = "This is a comprehensive test text that should definitely meet the minimum 300 character requirement for the Winston.ai API. We are testing the AI detection capabilities of this service to ensure it can properly analyze content and provide accurate scoring. The system should be able to detect whether this text was written by a human or generated by an AI language model. This is important for content quality assurance and ensuring the authenticity of generated materials in various applications including content generation, academic writing, and creative projects. The API should return a score between 0 and 100 indicating the likelihood of AI generation."
            test_payload = {"text": test_text}
            response = self.session.post(
                f"{self.base_url}/v2/ai-content-detection",
                json=test_payload,
                timeout=10
            )
            return response.status_code == 200
        except Exception:
            return False

    def _get_api_key(self) -> Optional[str]:
        """Get Winston.ai API key from environment or config"""
        # Load environment variables first
        try:
            from api.env_loader import EnvLoader
            EnvLoader.load_env()
        except ImportError:
            logger.warning("Could not load environment - continuing without .env loading")
        
        # Try environment variable first
        api_key = os.getenv('WINSTON_API_KEY')

        # Fallback to config file
        if not api_key:
            config_path = Path("config/ai_detection.yaml")
            if config_path.exists():
                try:
                    import yaml
                    with open(config_path, 'r') as f:
                        data = yaml.safe_load(f)
                    winston_config = data.get('winston', {})
                    api_key = winston_config.get('api_key')
                except Exception:
                    pass

        return api_key
